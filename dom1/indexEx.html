<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>복습</title>
</head>
<body>
    <script>
        let users = [
            { id: 11, name: 'Adam', age: 19, group: 'editor' },
            { id: 47, name: 'John', age: 28, group: 'admin' },
            { id: 85, name: 'William', age: 34, group: 'editor' },
            { id: 97, name: 'Oliver', age: 28, group: 'admin' }
        ];

        // => {28:2, 19:1, 34:1} -> 28살이 2명, 19살, 34살이 1명
        // result는 비어있는값, user은 배열의 값
        // 오브젝트를 리턴
        // 기존에 있던 result를 풀어(전개식으로), user.age를 추가
        // user.age라는 키에 (result[user.age] || 0) + 1를 넣음
        // {}은 함수라고 인식해서 ()로 감싸준다.
        let s = users.reduce( (result, user) => 
        ({...result, [user.age] : (result[user.age] || 0) + 1}), {});

        // 같은 거
        // result는 비어있는 값 -> result에 user.age라는 속성이 언디파인드이면
        // result에 user.age에 1를 넣어주고 그렇지 않으면 1증가
        // if (result[user.age] === undefined) {
        //     result[user.age] = 1;
        // } else {
        //     result[user.age]++;
        // }
        // return result;
        console.log(s);

        // Set -> 집합 중복 허락 X
        let a = new Set([1, 2, 3, 2, 2, 3, 3, 1, 1, 1, 2]);
        console.log(a); // 배열ㄴㄴ, set이라는 새로운 오브젝트
        console.log( [...a]); // 배열
        
        // users의 그룹 중복X
        let list = new Set(users.map(x => x.group));
        console.log( [...list] );

        let params = {lat: 45, lng: 6, alt: 1000};
        // let a2 = Object.entries(params);
        let a2 = Object.entries(params).map(
            p => encodeURIComponent(p[0]) + "=" + encodeURIComponent(p[1])).join("&");
        console.log(a2);
        console.log(params);
        
    </script>
</body>
</html>